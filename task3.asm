%include "io64.inc"  ; Подключение библиотеки для ввода/вывода (например, для печати значений)

section .data
    ; Значения a и b
    a dd 0.1                  ; Пример значения a
    b dd 0.5                  ; Пример значения b
    x dd 0.4                  ; Начальное значение для x

    debug_b dd 0.0            ; Для отладки b
    debug_arccos dd 0.0       ; Для отладки arccos(b)
    debug_x dd 0.0            ; Для отладки x

section .bss
    ; Результаты вычислений
    res_x resd 1  ; Переменная для хранения результата вычисления x

section .text
    global main

main:
    mov rbp, rsp               ; Для корректного дебага
    finit                      ; Инициализация FPU (сброс всех флагов и установка нормального состояния FPU)

; ===== Task 3: Проверка cos(ln(x + a)) = b =====
task3_x87:
    ; Загрузка 1 в стек FPU.
    fld1 

    ; Загружаем значение b в стек FPU.
    fld dword [b] 

    ; Вычисление 1 - b, результат сохраняется в st0
    fsubp st1, st0 

    ; Загружаем 1 в стек FPU.
    fld1 

    ; Загружаем снова b в стек FPU.
    fld dword [b] 

    ; Вычисление 1 + b, результат сохраняется в st0.
    faddp st1, st0 

    ; Деление (1 - b) / (1 + b)
    fdiv 

    ; Вычисление квадратного корня из результата
    fsqrt 

    ; Загрузка 1 в стек FPU.
    fld1 

    ; Вычисление арктангенса от текущего значения в стеке (арктангенс от результата деления)
    fpatan 

    ; Загружаем 1 в стек FPU дважды, для дальнейших вычислений
    fld1 
    fld1 

    ; Вычисление 2 (1 + 1 = 2)
    faddp st1, st0 

    ; Умножение результата на 2
    fmulp st1, st0 

    ; Копируем результат в st0.
    fld st0 

    ; Загружаем значение log2(e) в стек (стандартное значение для вычисления логарифмов по основанию 2)
    fldl2e 

    ; Умножаем результат на log2(e), это соответствует логарифмированию (например, ln)
    fmulp st1, st0 

    ; Копируем результат обратно в стек
    fld st0 

    ; Округление к целому значению (только целая часть)
    frndint 

    ; Вычитаем целую часть, оставляем только дробную
    fsub st1, st0 

    ; Обмен значениями в регистрах st0 и st1
    fxch 

    ; Вычисляем 2^(дробная часть) - 1
    f2xm1 

    ; Загрузка 1 в стэк для корректировки результата
    fld1 

    ; Добавляем 1 для получения 2^(дробная часть)
    fadd 

    ; Масштабируем результат (вычисление значения 2^(дробная часть))
    fscale 

    ; Очистка стека FPU (удаляем ненужные значения)
    fstp st1 
    fstp st1 

    ; Загружаем значение a.
    fld dword [a] 

    ; Вычитаем a из текущего значения результата.
    fsubp st1, st0 

    ; Сохраняем результат в переменную res_x.
    fstp dword [res_x] 

    ; Возвращаемся из функции
    ret
